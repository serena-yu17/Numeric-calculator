// Numeric calculator.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

#include <iostream>
#include <iomanip>
#include <string>
#include <cctype>
#include <cmath>
using namespace std;

int parseString(string, string*);
int isOperator(char);
string extractNum(char*, int&);
int getPriority(char);
double calcRevPolish(string*, int);
string filterStr(string);
char lowerCase(char);
string lowerCase(string);

///////////////////////////////////////////////////////////////////
//Template class implementing the stack structure
template <typename T>
class Stack
{
private:
	T* stackArray = nullptr;
public:
	T* top = nullptr;

	void push(T elem)
	{
		if (top == nullptr)
			top = stackArray;
		else
			top++;
		*top = elem;
	}

	T pop()
	{
		if (top == nullptr)
		{
			//cerr << "An empty array cannot be popped." << endl;	//For test use.
			return 0;
		}
		else if (top == stackArray)
		{
			T temp = *top;
			top = nullptr;
			return temp;
		}
		else
		{
			top--;
			return *(top + 1);
		}
	}

	inline int isEmpty()
	{
		if (top == nullptr)
			return 1;
		else return 0;
	}

	//To perform the basic calculations
	double calc(char operate)
	{
		double firstNum, secondNum;
		switch (operate)
		{
		case '+':
			secondNum = this->pop();
			firstNum = this->pop();
			return firstNum + secondNum;
		case '-':
			secondNum = this->pop();
			firstNum = this->pop();
			return firstNum - secondNum;
		case '*':
			secondNum = this->pop();
			firstNum = this->pop();
			return firstNum * secondNum;
		case '/':
			secondNum = this->pop();
			firstNum = this->pop();
			if (secondNum == 0)
			{
				cerr << "Divisor cannot be 0." << endl;
				err = 1;
				return 0;
			}
			return firstNum / secondNum;
			break;
		case 'l':
			secondNum = this->pop();
			firstNum = this->pop();
			if (firstNum <= 0 || secondNum <= 0)
			{
				cerr << "A logarithm does not exist for numbers <= 0." << endl;
				err = 1;
				return 0;
			}
			return log(secondNum) / log(firstNum);
		case 'r':
			secondNum = this->pop();
			firstNum = this->pop();
			return pow(secondNum, (1 / firstNum));
			break;
		}
	}

	Stack(int size)
	{
		stackArray = new T[size];
	}

	~Stack()
	{
		delete[] stackArray;
		stackArray = nullptr;
	}
};
///////////////////////////////////////////////////////////////////

int maxSize;	//The size of input
int err = 0;	//Indicates mathematical errors

int main()
{
	string exp;
	while (1)
	{
		cout << "Input your math expression:" << endl;
		getline(cin, exp);
		maxSize = exp.size();
		string* outstr = new string[maxSize + 1];
		int count = parseString(exp, outstr);
		double result = calcRevPolish(outstr, count);
		if (err == 1)
		{
			cerr << "Error\n" << endl;
			err = 0;
		}
		else
			cout << setprecision(16) << result << '\n' << endl;
		//cleanup
		delete[] outstr;
	}
}

//calculate the reverse Polish syntax generated by parseString()
double calcRevPolish(string* revPolish, int count)
{
	int i = 0;
	Stack<double>* dstack = new Stack<double>(count);
	while (i < count)
	{
		while (isdigit(revPolish[i][0]) || revPolish[i][0] == '.' || (revPolish[i][0] == '-' && isdigit(revPolish[i][1])))
		{
			dstack->push(stod(revPolish[i]));
			i++;
		}
		double stepResult = dstack->calc(revPolish[i][0]);
		dstack->push(stepResult);
		i++;
		if (err == 1)
			return 0;
	}
	double result = dstack->pop();
	//cleanup
	delete dstack;
	dstack = nullptr;
	//cleanup
	return result;
}

//Process the input string into an array of reverse Polish strings. Numbers are recorded as strings, too.
int parseString(string raw, string* outstr)
{
	string exp = filterStr(raw);
	maxSize = exp.size();
	int i = 0;
	Stack<char>* stack = new Stack<char>(maxSize);
	int outcount = 0;
	int minus = 0;
	while (i < maxSize)
	{
		if (exp[i] == '-' && (i == 0 || exp[i - 1] == '(') && isdigit(exp[i + 1]))
		{
			outstr[outcount++].push_back('0');
			minus = 1;
			i++;
		}
		if (isdigit(exp[i]) || exp[i] == '.')
		{
			int count = 0;
			outstr[outcount++] = extractNum(&exp[i], count);	//A string that reads the digits that form an operon
			i += count;	//move the reading point forward
		}
		if (minus == 1)
		{
			outstr[outcount++].push_back('-');
			minus = 0;
		}
		if (isOperator(exp[i]))
		{
			if (exp[i] == ')')	//With a closed parentheses, pop all out until the last opening parentheses
			{
				while (!stack->isEmpty() && *(stack->top) != '(')
				{
					outstr[outcount++].push_back(stack->pop());
				}
				stack->pop();
				i++;
			}
			//Never pop an opening bracket unless receiving a closing one
			while (!stack->isEmpty() && getPriority(exp[i]) <= getPriority(*(stack->top)) && *(stack->top) != '(')
				outstr[outcount++].push_back(stack->pop());
			if (i < maxSize)
			{
				stack->push(exp[i]);
				i++;
			}
		}
	}
	//pop out all remaining elements
	while (!stack->isEmpty())
	{
		outstr[outcount++].push_back(stack->pop());
	}
	//cleanup
	delete stack;
	stack = nullptr;
	//cleanup
	return outcount;
}

//priority of operators. Parentheses can be ignored, since they will be parsed separately
inline int getPriority(char op)
{
	switch (op)
	{
	case '+':
	case '-':
		return 0;
	case '*':
	case '/':
		return 1;
	case'l':
		return 3;
	case 'r':
		return 2;
	case '(':
	case ')':
		return 100;
	}
}

//Only these operators are supported
int isOperator(char ch)
{
	ch = lowerCase(ch);
	if (ch == '(' || ch == ')' || ch == '+' || ch == '-' || ch == '*' || ch == '/' || ch == 'r' || ch == 'l')
		return 1;
	else return 0;
}

//A string overload of the above isOperator function
int isOperator(string str)
{
	return isOperator(str[0]);
}

//Read from the char string until the number ends and an operator appears
string extractNum(char* raw, int& count)
{
	string outstr;
	while (isdigit(raw[count]) || raw[count] == '.')
	{
		outstr.push_back(raw[count]);
		count++;
	}
	return outstr;
}

//To remove all non-numbers, non-operators, and abbraviate "sqrt" to 's' and "log" to 'l'.
string filterStr(string exp)
{
	string outstr;
	int i = 0;
	while (i < exp.size())
	{
		if (lowerCase(exp.substr(i, 4)) == "sqrt")
		{
			outstr.append("2r");
			i += 4;
		}
		if (lowerCase(exp.substr(i, 3)) == "log")
		{
			if (!isdigit(exp[i - 1]))
				outstr.push_back('2');
			outstr.push_back('l');
			i += 3;
		}
		if (lowerCase(exp.substr(i, 4)) == "root")
		{
			outstr.push_back('r');
			i += 4;
		}
		if (isdigit(exp[i]) || exp[i] == '.' || isOperator(exp[i]))
			outstr.push_back(exp[i]);
		i++;
	}
	return outstr;
}

//get the lower case of the string, used for sqrt and log
string lowerCase(string str)
{
	for (int i = 0; i < str.size(); i++)
		if (str[i] >= 'A' && str[i] <= 'Z')
			str[i] -= 'A' - 'a';
	return str;
}

//get the lower case of the char, used for s and l
char lowerCase(char ch)
{
	if (ch >= 'A' && ch <= 'Z')
		ch -= 'A' - 'a';
	return ch;
}

