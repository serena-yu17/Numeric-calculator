// Numeric calculator.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

#include <iostream>
#include <string>
#include <cctype>
#include <iomanip>
using namespace std;

int parseString(string, string*);
int isOperator(char);
double calc(double firstNum, char operate, double secondNum);
string extractNum(char*, int&);
string filterstr(string);
int getPriority(char);
double calcRevPolish(string*, int);
template <typename T>
class Stack
{
private:
	T* stackArray = nullptr;
public:
	T* top = nullptr;
	void push(T elem)
	{
		if (top == nullptr)
			top = stackArray;
		else
			top++;
		*top = elem;
	}
	T pop()
	{
		if (top == nullptr)
		{
			cerr << "An empty array cannot be popped." << endl;
			return 0;
		}
		else if (top == stackArray)
		{
			T temp = *top;
			top = nullptr;
			return temp;
		}
		else
		{
			top--;
			return *(top + 1);
		}
	}
	inline int isEmpty()
	{
		if (top == nullptr)
			return 1;
		else return 0;
	}
	Stack(int size)
	{
		stackArray = new T[size];
	}
	~Stack()
	{
		delete[] stackArray;
		stackArray = nullptr;
	}
};


//The size of input
int maxSize;

int main()
{
	string exp;
	while (1)
	{
		cout << "Input your expression:" << endl;
		getline(cin, exp);
		maxSize = exp.size();
		string* outstr = new string[maxSize + 1];
		int count = parseString(exp, outstr);
		double result = calcRevPolish(outstr, count);
		cout << setprecision(16) << result << endl;
		//cleanup
		delete[] outstr;
	}
}

//calculate the reverse Polish syntax generated by parseString()
double calcRevPolish(string* revPolish, int count)
{
	int i = 0;
	Stack<double>* dstack = new Stack<double>(count);
	while (i < count)
	{
		while (isdigit(revPolish[i][0]) || revPolish[i][0] == '.' || (revPolish[i][0] == '-' && isdigit(revPolish[i][1])))
		{
			dstack->push(stod(revPolish[i]));
			i++;
		}
		double num1 = dstack->pop();
		double num2 = dstack->pop();
		double result = calc(num2, revPolish[i][0], num1);
		i++;
		dstack->push(result);
	}
	double result = dstack->pop();
	//cleanup
	delete dstack;
	dstack = nullptr;
	//cleanup
	return result;
}

//Process the input string into an array of reverse Polish strings. Numbers are recorded as strings, too.
int parseString(string raw, string* outstr)
{
	string exp = filterstr(raw);
	maxSize = exp.size();
	int i = 0;
	int isPositive = 1;	//indicates if the current number is positive
	Stack<char>* stack = new Stack<char>(maxSize);
	int outcount = 0;
	while (i < maxSize)
	{
		if (exp[i] == '-' && (i == 0 || exp[i - 1] == '(') && isdigit(exp[i + 1]))
		{
			isPositive = -1;
			i++;
		}
		if (isdigit(exp[i]) || exp[i] == '.')
		{
			int count = 0;
			string tempstr = extractNum(&exp[i], count);	//A string that reads the digits that form an operon
			//if this number starts with '-' sign, set it as minus
			if (isPositive == -1)
			{
				outstr[outcount].push_back('-');
				isPositive = 1;	//reset positivity status
			}
			outstr[outcount] += tempstr;	//send the operon to the formatted string array
			outcount++;	//process the next operator or operon
			i += count;	//move the reading point forward
		}
		else if (isOperator(exp[i]))
		{
			if (exp[i] == ')')	//With a closed parentheses, pop all out until the last opening parentheses
			{
				while (!stack->isEmpty() && *(stack->top) != '(')
				{
					outstr[outcount++].push_back(stack->pop());
				}
				stack->pop();
				i++;
			}
			//Never pop an opening parentheses unless receiving a closing parentheses
			while (!stack->isEmpty() && getPriority(exp[i]) <= getPriority(*(stack->top)) && *(stack->top) != '(')
			{
				outstr[outcount++].push_back(stack->pop());
			}
			if (i < maxSize)
			{
				stack->push(exp[i]);
				i++;
			}
		}
	}
	//pop out all remaining elements
	while (!stack->isEmpty())
	{
		outstr[outcount++].push_back(stack->pop());
	}
	//cleanup
	delete stack;
	stack = nullptr;
	//cleanup
	return outcount;
}
//To remove all non-numbers, non-operators
string filterstr(string instr)
{
	string outstr;
	for (int i = 0; i < instr.size(); i++)
	{
		if (isdigit(instr[i]) || instr[i] == '.' || isOperator(instr[i]))
		{
			outstr.push_back(instr[i]);
		}
	}
	return outstr;
}
//priority of operators. Parentheses can be ignored, since they will be processed separately anyway
int getPriority(char op)
{
	switch (op)
	{
	case '+':
	case '-':
		return 0;
	case '*':
	case '/':
		return 1;
	}
}
//To chack if a char is an operator
int isOperator(char ch)
{
	if (ch == '(' || ch == ')' || ch == '+' || ch == '-' || ch == '*' || ch == '/')
		return 1;
	else return 0;
}
//just for convenience. A string with length of 1 is basically the same thing as char
int isOperator(string str)
{
	char ch = str[0];
	return isOperator(ch);
}
//To perform the basic calculations
inline double calc(double firstNum, char operate, double secondNum)
{
	switch (operate)
	{
	case '+':
		return firstNum + secondNum;
		break;
	case '-':
		return firstNum - secondNum;
		break;
	case '*':
		return firstNum * secondNum;
		break;
	case '/':
		return firstNum / secondNum;
		break;
	}
}
//Read from the char string until the number ends and an operator appears
string extractNum(char* raw, int& count)
{
	string outstr;
	while (isdigit(raw[count]) || raw[count] == '.')
	{
		outstr.push_back(raw[count]);
		count++;
	}
	return outstr;
}




